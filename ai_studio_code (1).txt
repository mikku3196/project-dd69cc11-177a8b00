# 【完全版ブループリント】自己進化型AIポートフォリオ自動売買システム

## 1. プロジェクト概要

### 1.1. 目的・ゴール

*   **目的**: Bybit APIとGoogle Gemini APIを核とし、複数の取引戦略を自己最適化させながら並行稼働させる。市場の変化に自動で適応し、利益を追求しつつリスクを徹底的に管理する、自己完結型の資産運用システムを構築する。
*   **ゴール**: 人間の感情と労力を完全に排した、データ駆動型の合理的な資産運用を完全自律で行い、長期的に安定した資産形成を実現する。

### 1.2. 核心的コンセプト

本システムは、単一の売買ボットではなく、複数のAIエージェント（サブボット）、統括AI（マスターボット）、そして自己学習メカニズムが連携して動作する自律型資産運用エコシステムである。戦略の意思決定、リスク管理、資金配分、利益確保、そして戦略自体の最適化まで、全てを自動で完結させる。

## 2. 設計思想と運用原則

### 2.1. 完全自律性 (Full Autonomy)

**原則**: 本システムは、初期設定完了後、人間の承認や操作を一切介さずに24時間35日稼働し続ける。パラメータの更新、資金のリバランス、利益確保など、全ての運用判断はシステム自身が自動的に実行する。人間はダッシュボードを通じて「監視」するのみとする。

### 2.2. 動的自己最適化 (Dynamic Self-Optimization)

**原則**: 市場に静的な「聖杯」は存在しない。システムは定期的に自己のパフォーマンスを過去データと照らし合わせて評価し、現在の市場に最も適したパラメータ（損切り率、取引量など）を自動的に計算し、適用する。

### 2.3. 階層的リスク管理 (Hierarchical Risk Management)

**原則**: リスク管理は複数の層で実行する。ミクロレベル（個別取引のTP/SL）、メゾレベル（ボラティリティに応じた取引量調整）、マクロレベル（市場全体のサーキットブレーカー）の階層的な安全装置により、いかなる市場環境でも致命的な損失を回避する。

### 2.4. 徹底した記録と再現性 (Thorough Logging & Reproducibility)

**原則**: 全ての行動は記録され、検証可能でなければならない。Gitによるコード・設定のバージョン管理、データベースへの全取引・判断ログの記録により、システムのあらゆる挙動の完全な再現性を担保する。

### 2.5. システム健全性の自己監視 (System Health Self-Monitoring)

**原則**: システムは取引戦略だけでなく、それ自体が稼働するサーバー（Ubuntu）の健康状態も監視対象とする。リソースの異常は取引パフォーマンスの異常に直結するため、これを自動検知し、管理者に警告する。

## 3. システムアーキテクチャ

### 3.1. 実行環境・開発スタック

*   **実行環境**: Ubuntu (LTS版を推奨)
*   **開発言語**: Python 3.10+
*   **主要ライブラリ・フレームワーク**:
    *   **Web API/ダッシュボード**: FastAPI
    *   **タスクスケジューリング**: APScheduler
    *   **API通信**: Requests, aiohttp
    *   **データ操作・分析**: Pandas, NumPy
    *   **データベース**: SQLAlchemy (ORM), Alembic (マイグレーション)
    *   **バージョン管理**: Git

### 3.2. モジュール構成
[ 外部API (Bybit, Gemini, News API, Discord) ]
^ ^ ^
| | |
+---------------------------------------------------+
| マスターボット (Master Bot) |
|---------------------------------------------------|
| [統括管理レイヤー] |
| - ポートフォリオ管理 (市場フェーズ分析, リバランス) |
| - リスク管理 (サーキットブレーカー, 資金確保) |
| - 最適化エンジン (バックテスト, パラメータ更新) |
| - 監視 & 通知 (リソース監視, Discord通知) |
+---------------------------------------------------+
| | |
v v v
+---------------+ +---------------+ +---------------+
| サブボット A | | サブボット B | | サブボット C |
| (安定志向) | | (バランス重視) | | (積極果敢) |
|---------------| |---------------| |---------------|
| [取引実行レイヤー] | | [取引実行レイヤー] | | [取引実行レイヤー] |
| - 意思決定 | | - 意思決定 | | - 意思決定 |
| - ポジション管理| | - ポジション管理| | - ポジション管理|
| - リスク計算 | | - リスク計算 | | - リスク計算 |
+---------------+ +---------------+ +---------------+
^ ^ ^
| | |
+---------------------------------------------------+
| データ & ユーティリティレイヤー |
|---------------------------------------------------|
| - データベース (SQLite/PostgreSQL) |
| - データ収集モジュール (価格, ニュース) |
| - APIクライアント (Bybit, Gemini) |
| - Webダッシュボード (FastAPI + Frontend) |
+---------------------------------------------------+

## 4. 機能要件詳細

### 4.1. 意思決定エンジン (Gemini)
*   **目的**: 市場データとニュースを総合的に分析し、質の高い売買判断を生成する。
*   **処理フロー**:
    1.  複数のGemini APIキーを設定ファイルから読み込み、リストとして保持する。
    2.  リクエストごとに、リストからAPIキーを順番に使用する（レートリミット対策）。
    3.  価格データ、テクニカル指標、ニュースセンチメントスコアを結合し、構造化されたプロンプトを生成する。
    4.  Gemini APIにプロンプトを送信し、`{ "action": "BUY", "confidence": 0.85, "reason": "..." }`のようなJSON形式での応答を要求する。
    5.  応答のパースに失敗した場合や、エラーが返ってきた場合は、リトライ処理を行い、数回失敗した場合はDiscordにエラー通知を送信する。
*   **設定項目**: `gemini_api_keys` (リスト形式), `request_timeout`, `retry_attempts`.

### 4.2. ニュース・センチメント分析モジュール
*   **目的**: 定量的な価格データに加え、定性的な市場心理（ファンダメンタルズ）を判断材料に加える。
*   **処理フロー**:
    1.  指定されたニュースソースから、設定されたキーワードを含む記事を定期的に取得する。
    2.  取得した記事の本文をGemini APIに送信し、「この記事は暗号資産市場に対してポジティブ、ネガティブ、ニュートラルのどれですか？-1.0（非常にネガティブ）から+1.0（非常にポジティブ）の範囲でスコアを付けてください」というプロンプトで分析させる。
    3.  返されたスコアを、記事のソースとタイムスタンプと共にデータベースに保存する。
    4.  直近の移動平均センチメントスコアを計算し、他のサブボットが参照できるようにする。
*   **設定項目**: `news_sources` (URLリスト), `keywords` (リスト), `fetch_interval`, `sentiment_moving_average_period`.

### 4.3. サブボット共通機能

#### 4.3.1. 動的ポジションサイジング
*   **目的**: 市場の変動性に応じて取引量を自動調整し、リスクを一定に保つ。
*   **処理フロー**:
    1.  取引判断の直前に、対象通貨のボラティリティ指標（例: ATR）を計算する。
    2.  計算されたATRが設定された閾値（低・中・高）のどの範囲にあるかを判断する。
    3.  範囲に応じて、基本となる取引ロット数に乗算する係数を決定する。
    4.  最終的な取引量を算出し、注文を実行する。
*   **設定項目**: `volatility_indicator` (例: 'ATR'), `atr_period`, `volatility_thresholds`, `sizing_multipliers`.

#### 4.3.2. 段階的エントリー（分割売買）
*   **目的**: 一括でのエントリーを避け、高値掴み/安値売りのリスクを低減し、平均取得単価を改善する。
*   **処理フロー**:
    1.  Geminiから「買い」のシグナルを受け取ったら、総取引予定量を設定された分割回数で割る。
    2.  1回目のエントリーを即座に実行する。
    3.  残りの注文は、指定された時間間隔または価格乖離の条件で、指値注文として発注する。
    4.  全ての分割注文が約定するか、一定時間が経過したら、ポジション全体の平均取得単価とTP/SLを再計算して設定する。
*   **設定項目**: `split_entry_count`, `split_entry_method` ('time' or 'price'), `split_entry_interval`.

### 4.4. マスターボット機能

#### 4.4.1. 市場フェーズ適応型ポートフォリオ
*   **目的**: 市場全体の「トレンド」を読み、その状況に最も適した戦略ボットへ資金を重点的に配分する。
*   **処理フロー**:
    1.  定期的に、主要なインデックスのトレンド指標を分析する。
    2.  市場を「強い上昇トレンド」「弱い上昇トレンド」「レンジ」「弱い下降トレンド」「強い下降トレンド」の5段階などで判定する。
    3.  各フェーズに対して、あらかじめ定義された資金配分比率を読み込む。
    4.  現在の各サブアカウントの資産比率が目標比率と乖離している場合、資金移動を実行してリバランスする。
*   **設定項目**: `market_phase_indicator`, `phase_definitions`, `phase_allocations`.

#### 4.4.2. 利益確保機能 (プロフィット・セービング)
*   **目的**: 得られた利益を定期的に非取引口座に隔離し、将来のドローダウンから保護する。
*   **処理フロー**:
    1.  毎週日曜00:00に処理を実行する。
    2.  収益がプラスのサブアカウントについて、利益額 × 設定された確保率 で移動させる資金額を決定する。
    3.  Bybit APIを利用して、算出した額を当該サブアカウントからメインアカウントへ移動させる。
    4.  実行結果をDiscordとデータベースに記録する。
*   **設定項目**: `profit_save_interval` ('weekly'), `profit_save_rate` (デフォルト: 0.5 = 50%).

### 4.5. 運用・監視ツール

#### 4.5.1. Webダッシュボード
*   **目的**: システムの全状況を視覚的に、リアルタイムで把握するためのインターフェース。
*   **表示項目**:
    *   **サマリー**: 総資産額、24時間損益、確保済み利益総額、システムステータス。
    *   **ポートフォリオ**: 各サブアカウントの資産配分円グラフ、各ボットの資産額と累計損益グラフ。
    *   **取引履歴**: 全取引の詳細テーブル（フィルタリング・ソート機能付き）。
    *   **パフォーマンス分析**: シャープレシオ、勝率、プロフィットファクターなどの主要指標。
    *   **ログビューア**: システムの生ログをリアルタイム表示。
*   **手動介入パネル**:
    *   **目的**: 人間が最終的な安全装置として介入するための機能。
    *   **機能**:
        *   [ 全システム緊急停止/再開 ] ボタン
        *   [ 全ポジション強制決済 ] ボタン
        *   [ ボット別 停止/再開 ] スイッチ

### 4.6. 学習・最適化エンジン

#### 4.6.1. バックテスト機能
*   **目的**: 過去データを用いて、戦略やパラメータの有効性を高速で検証する。
*   **処理フロー**:
    1.  ダッシュボードから、対象期間、対象ボット、テストしたいパラメータ範囲を指定して開始する。
    2.  指定された過去の価格データをデータベースから読み込む。
    3.  手数料やスリッページも考慮した、現実的なシミュレーションを行う。
    4.  テスト終了後、最終損益、各種パフォーマンス指標、資産推移グラフを生成し、結果を表示する。

#### 4.6.2. 動的パラメータ自動チューニング
*   **目的**: システム自身が継続的に学習し、市場に適応し続ける「自己進化」の核となる機能。
*   **処理フロー**:
    1.  毎月1日の01:00に自動で実行する。
    2.  過去のデータを対象に、主要なパラメータを範囲内で変化させながら、総当たりでバックテストを実行する（グリッドサーチ）。
    3.  最もパフォーマンス（例: シャープレシオが最大）が良かったパラメータの組み合わせを「最適解」として選出する。
    4.  現在のパラメータより最適解が優れていた場合、設定ファイルを自動で書き換えて更新する。
    5.  システムを自動で再起動し、新しい設定を適用する。
    6.  実行結果の詳細なレポートをDiscordに通知する。

---
## 5. 非機能要件

### 5.1. セキュリティ (Security)
*   **APIキー管理**: 全てのAPIキーは、ソースコードに直接記述せず、**環境変数**または**`.env`ファイル**で管理する。
*   **ダッシュボードアクセス制御**: FastAPIに**Basic認証**を実装し、許可されたユーザーのみがアクセス可能にする。IPアドレスによるアクセス制限も併用する。
*   **外部API通信**: 全ての外部APIとの通信は**HTTPS**を強制する。

### 5.2. 信頼性・可用性 (Reliability & Availability)
*   **稼働率目標**: **99.9%**の月間稼働率を目標とする。
*   **プロセス管理**: `systemd`サービスとして登録し、OS起動時の自動起動と、クラッシュ時の**自動再起動**を保証する。
*   **データベースの堅牢性**:
    *   **開発・テスト**: **SQLite**
    *   **本番稼働**: **PostgreSQL**への移行を必須とし、定期的な自動バックアップを設定する。

### 5.3. パフォーマンス (Performance)
*   **API応答時間**: ダッシュボードのAPIは、全て**500ms以内**に応答を返すことを目標とする。
*   **バックテスト実行速度**: 過去1年分の1分足データに対するバックテストが、**5分以内**に完了することを目指す。

---
## 6. 設定ファイル (`config.toml`) 完全定義

可読性が高くコメントも記述しやすい**TOML形式**を採用し、全パラメータを網羅する。

```toml
# config.toml

# --- グローバル設定 ---
[general]
environment = "production"  # "development", "testnet", "production"
debug_mode = false
timezone = "UTC"

# --- データベース設定 ---
[database]
db_type = "postgresql"  # "sqlite" or "postgresql"
db_url = "postgresql://user:password@host:port/dbname" # 環境変数で上書き推奨

# --- APIキー設定 (環境変数からの読み込みを推奨) ---
[api_keys]
# bybit_api_key = "YOUR_BYBIT_API_KEY"
# bybit_api_secret = "YOUR_BYBIT_API_SECRET"
# gemini_api_keys = ["KEY1", "KEY2", "KEY3"]
# discord_webhook_url = "YOUR_DISCORD_WEBHOOK_URL"

# --- マスターボット設定 ---
[master_bot]
rebalance_interval_hours = 4
profit_save_day = "Sunday"    # 利益確保を実行する曜日
profit_save_hour = 0          # 実行時刻 (UTC)
profit_save_rate = 0.5        # 利益の50%を確保

# 市場フェーズの定義 (インジケーターと閾値)
[master_bot.market_phase]
indicator = "EMA_Cross" # 'EMA_Cross', 'ADX'など
short_period = 50
long_period = 200
# 各フェーズにおけるサブボットへの資金配分比率
[master_bot.allocations]
strong_bull = { sub_bot_A = 0.2, sub_bot_B = 0.3, sub_bot_C = 0.5 }
weak_bull   = { sub_bot_A = 0.3, sub_bot_B = 0.4, sub_bot_C = 0.3 }
ranging     = { sub_bot_A = 0.5, sub_bot_B = 0.3, sub_bot_C = 0.2 }
weak_bear   = { sub_bot_A = 0.3, sub_bot_B = 0.4, sub_bot_C = 0.3 }
strong_bear = { sub_bot_A = 0.2, sub_bot_B = 0.3, sub_bot_C = 0.5 }

# --- サブボット設定 (リスト形式で複数定義可能) ---
[[sub_bots]]
name = "SubBot-A (Stable)"
enabled = true
symbol = "BTC/USDT"
base_lot = 0.001
# 動的ポジションサイジング設定
[sub_bots.dynamic_sizing]
enabled = true
volatility_indicator = "ATR"
atr_period = 14
# ボラティリティの閾値 (ATR値)
volatility_thresholds = { low = 100.0, medium = 300.0 }
# 各閾値でのロット倍率
sizing_multipliers = { low = 1.0, medium = 0.75, high = 0.5 }
# 段階的エントリー設定
[sub_bots.split_entry]
enabled = true
count = 3
method = "time" # 'time' or 'price'
interval_seconds = 60
# その他戦略パラメータ
[sub_bots.strategy_params]
tp_ratio = 1.5 # リスクリワード比
sl_ratio = 1.0

# --- (以下、SubBot-B, SubBot-C と続く) ---

# --- ニュース・センチメント分析設定 ---
[news_sentiment]
enabled = true
fetch_interval_minutes = 15
keywords = ["Bitcoin", "BTC", "crypto", "FOMC", "inflation"]
sources = [
    "https://news.google.com/rss/search?q=bitcoin&hl=en-US&gl=US&ceid=US:en"
]
moving_average_period_hours = 24

# --- 学習・最適化エンジン設定 ---
[optimizer]
auto_tuning_enabled = true
schedule = "0 1 1 * *" # 毎月1日 AM1:00 に実行 (cron形式)
backtest_period_months = 6
target_metric = "sharpe_ratio" # 'profit', 'sharpe_ratio', 'max_drawdown'
# 最適化対象のパラメータ範囲
[optimizer.param_ranges]
"SubBot-A.strategy_params.sl_ratio" = { start = 0.5, end = 2.0, step = 0.1 }
"SubBot-C.dynamic_sizing.atr_period" = { start = 10, end = 30, step = 2 }
7. データモデル（データベーススキーマ）定義
trades (取引履歴)
id: INTEGER, Primary Key
timestamp: DATETIME, UTC
sub_bot_name: VARCHAR
symbol: VARCHAR
order_id: VARCHAR, Unique
side: VARCHAR ('BUY' or 'SELL')
price: DECIMAL
quantity: DECIMAL
fee: DECIMAL
pnl: DECIMAL
entry_reason: TEXT (Geminiの分析結果)
portfolio_history (資産履歴)
id: INTEGER, Primary Key
timestamp: DATETIME, UTC
total_balance_usdt: DECIMAL
sub_bot_A_balance: DECIMAL
sub_bot_B_balance: DECIMAL
sub_bot_C_balance: DECIMAL
profit_saved_balance: DECIMAL
sentiment_scores (センチメントスコア)
id: INTEGER, Primary Key
timestamp: DATETIME, UTC
source: VARCHAR (ニュースソースURL)
keyword: VARCHAR
score: DECIMAL (-1.0 to 1.0)
headline: TEXT
system_events (システムイベントログ)
id: INTEGER, Primary Key
timestamp: DATETIME, UTC
level: VARCHAR ('INFO', 'WARNING', 'ERROR', 'CRITICAL')
event_type: VARCHAR ('STARTUP', 'SHUTDOWN', 'REBALANCE', 'PARAM_UPDATE')
message: TEXT
details: JSON
8. エラーハンドリングとロギング戦略
8.1. ログレベル定義
INFO: 正常な動作の記録（システムの起動・停止、取引実行など）。
WARNING: 軽微なエラー（リトライで成功したAPIエラーなど）。
ERROR: 処理が続行できないエラー（注文失敗、DB接続断など）。
CRITICAL: システムがクラッシュする致命的なエラー。
8.2. ロギング設定
標準出力（コンソール）とファイルの両方に出力する。
ログファイルは日次でローテーションし、過去30日分を保持する。
フォーマット: [タイムスタンプ] [ログレベル] [モジュール名] メッセージ
8.3. 具体的なエラー対応
Bybit APIエラー: 5xx系エラーやタイムアウトは、エクスポネンシャルバックオフで最大3回リトライする。失敗し続けた場合はERRORを記録し、Discordに通知後、該当ボットを一時停止する。
Gemini APIエラー: レートリミットエラーが発生した場合、次のAPIキーに切り替える。全キーで失敗した場合はWARNINGを記録し、次のサイクルまでセンチメント分析をスキップする。
データベース接続エラー: 起動時に接続できない場合はCRITICALエラーでシステムを終了。稼働中に切断された場合は再接続を試み、失敗し続けるならシステムを安全に停止させる。
9. 開発・テスト・デプロイメント計画
9.1. 開発フェーズ
フェーズ1: 開発と単体テスト
Gitリポジトリを作成し、各モジュールをブランチを分けて開発。ユニットテストを記述する。
フェーズ2: 機械的テスト (Testnet環境)
Bybitのテストネットを使用し、API通信、注文実行、資金移動など、プログラムの機械的な動作が全てエラーなく実行できることを徹底的に検証する。
フェーズ3: 戦略的フォワードテスト (Live-Paper Tradingモード)
本番市場のライブデータに接続し、実際の資金を使わずにペーパー取引モードで最低1ヶ月以上運用。戦略の有効性、期待収益率、最大ドローダウンなどを現実的な環境で測定・評価する。
フェーズ4: 本番稼働 (Mainnet環境)
上記全てのテストをクリアした後、設定ファイルをmainnetに切り替え、少額の資金で運用を開始。徐々に資金額を増やしていく。
9.2. 開発・運用ワークフロー
Gitブランチ戦略: Git Flowを採用する。
main: 本番稼働中の安定バージョン。
develop: 次期リリースに向けた開発の統合ブランチ。
feature/xxx: 新機能開発用のブランチ。
hotfix/xxx: 緊急のバグ修正用のブランチ。
CI/CD (継続的インテグレーション/継続的デプロイメント)
GitHub Actionsを利用してCI/CDパイプラインを構築する。
push時: blackによるコードフォーマットチェックと、pytestによる単体テストを自動実行。
developへのマージ時: 上記に加え、Dockerイメージをビルドし、ステージング環境へ自動デプロイ。
mainへのマージ時: 本番環境へのデプロイを手動承認付きで実行。